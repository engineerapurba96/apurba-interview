Follow 
1. https://www.interviewbit.com/javascript-interview-questions/#output-of-following-code-2
2. https://www.interviewbit.com/javascript-mcq/

1.Write the code given If two strings are anagrams of one another, then return true.
solutions:
function areAnagram(str1,str2)
    {
        let n1 = str1.length;
        let n2 = str2.length;
        if (n1 != n2)
            return false;
        str1.sort();
        str2.sort()
        for (let i = 0; i < n1; i++)
            if (str1[i] != str2[i])
                return false;
   
        return true;
    }
    let str1=['g', 'r', 'a', 'm' ];
    let str2=['a', 'r', 'm' ,'g'];
     
    // Function Call
        if (areAnagram(str1, str2))
            document.write("The two strings are"
                               + " anagram of each other<br>");
        else
            document.write("The two strings are not"
                               + " anagram of each other<br>");


2.Write the code to find the vowels
Solutios:
const findVowels = str => {
  let count = 0
  const vowels = ['a', 'e', 'i', 'o', 'u']
  for(let char of str.toLowerCase()) {
    if(vowels.includes(char)) {
      count++
    }
  }
  return count
}
or
function isVowel(ch) {
        ch = ch.toUpperCase();
        return ch == "A" || ch == "E" || ch == "I" || ch == "O" || ch == "U";
      }
  
      // Returns count of vowels in str
      function countVowels(str)
      {
        var count = 0;
        for (var i = 0; i < str.length; i++)
          if (isVowel(str[i]))
            
            // Check for vowel
            ++count;
        return count;
      }
  
      // Main Calling Function
  
      // string object
      var str = "abc de";
  
      // Total numbers of Vowel
      document.write(countVowels(str));
      document.write("<br>");
	  
	  3. In JavaScript, how do you turn an Object into an Array []?
	  solutions:
	  

let obj = { id: "1", name: "user22", age: "26", work: "programmer" };

//Method 1: Convert the keys to Array using - Object.keys()
console.log(Object.keys(obj));
// ["id", "name", "age", "work"]

// Method 2 Converts the Values to Array using - Object.values()
console.log(Object.values(obj));
// ["1", "user22r", "26", "programmer"]

// Method 3 Converts both keys and values using - Object.entries()
console.log(Object.entries(obj));
//[["id", "1"],["name", "user22"],["age", "26"],["work", “programmer"]]

4. What is the output of the following code?
const b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

for (let i = 0; i < 10; i++) {
  setTimeout(() => console.log(b[i]), 1000);
}

for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(b[i]), 1000);
}
solutions:
1
2
3
4
5
6
7
8
9
10
undefined
undefined
undefined
undefined
undefined
undefined
undefined
undefined
undefined
undefined
5.A BigInt value, also sometimes just called a BigInt, is a bigint primitive, created by appending n to the end of an integer literal, 
or by calling the BigInt() function (without the new operator) and giving it an integer value or string value.
typeof 1n === "bigint"; // true
typeof BigInt("1") === "bigint"; // true

Symobl:
     Symbol - It is a new data type introduced in the ES6 version of javascript. It is used to store an anonymous and unique value.

Example :

var symbol1 = Symbol('symbol');

Because symbols are the only primitive data type that has reference identity (that is, you cannot create the same symbol twice), they behave like objects in some way.
Symbol("foo") === Symbol("foo"); // false
The following syntax with the new operator will throw a TypeError:


const sym = new Symbol(); // TypeError
6.// Hoisting takes place in the local scope as well
function doSomething(){
  x = 33;
  console.log(x);
  var x;
} 

doSomething(); // Outputs 33 since the local variable “x” is hoisted inside the local scope

    Note - Variable initializations are not hoisted, only variable declarations are hoisted:
	
	function doSomething(){
 var x;
  console.log(x);//undefined because Variable initializations are not hoisted
  x = 33;
}

doSomething();


var x;
console.log(x); // Outputs "undefined" since the initialization of "x" is not hoisted
x = 23;

Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code:
7."use strict";
x = 23; 
console.log(x);// Gives an error since 'x' is not declared

function strict_function() {
  'use strict';

  x = 'I am a strict function';

  console.log(x);
}

strict_function(); // ReferenceError: x is not defined

8. Difference between “ == “ and “ === “ operators.

Both are comparison operators. The difference between both the operators is that “==” is used to compare values whereas, “ === “ is used to compare both values and types.

Example:

var x = 2;
var y = "2";
(x == y)  // Returns true since the value of both x and y is the same
(x === y) // Returns false since the typeof x is "number" and typeof y is "string"

9.async vs defer in script tag in JavaScript? (https://codedamn.com/news/javascript/async-and-defer-in-script-tag)
Ans:
When it comes to loading external JavaScript files on your website, should you use async or defer? Both methods have their own advantages and disadvantages,
and there is no definitive answer. Ultimately, it depends on your specific needs. This blog post will explain what async and defer actually is and explore
 the differences between async and defer, so you can make an informed decision about which method is best for your use case.
 
Async in script tag in JavaScript is a way to load scripts asynchronously. That means, if a script is async, it will be loaded independently of other scripts on the page, and will not block the page from loading.

If you have a page with several external scripts, loading them all asynchronously can speed up the page load time, because the browser can download and execute them in parallel.

To use async, simply add the async attribute to your script tag:

<script async src="script.js"></script>

By using the defer attribute in HTML, the browser will load the script only after parsing (loading) the page. This can be helpful if you have a script that is dependent on other scripts, or if you want to improve the loading time of your page by loading scripts after the initial page load.

To use defer, simply add the defer attribute to your script tag:

<script defer src="script.js"></script>
The async and defer attributes both allow the browser to continue parsing the HTML document while JavaScript files are being downloaded, but they differ in when those files are 
executed.Async downloads and executes JavaScript as soon as it’s available, while defer attribute waits until the HTML document has been parsed before downloading and executing any external scripts.

In most cases, it doesn’t matter which attribute you use – both will improve performance by allowing the browser to continue parsing while waiting for JavaScript to download.
 However, there are some situations where one attribute may be preferable to the other.

10.Dynamically typed?
In dynamic-typed languages, we don’t need to define the type of a variable as an interpreter at run-time will handle it.

In the above code: Line 1: We declare a variable number and assign a value to it. Note that we have not defined its type here.

Line 2: We print the value of variable number on the console.

number = 10
print(number)

variable Namin:
11.Camecase  : nameFunctionParida = "Bubu;
pascelcasecase  : NameFunctionParida = 	"pari"
Snake case:  name_parida = "jioir"
Except _ and $ we can't use any special symbol in variable.We can write number in between but we can't write number with special symbol

var 123hd5=8;//like this also we can't 
console.log(123hd5);///error

var h45d5=8;//correct
console.log(h15d5);//8

var $123 = 56;//we can write this
console.log($123);//56

var 123$ = 56;//we can't write like this
console.log($123);//error

12.Coercien

Type coercion occurs when values of different data types are compared or used together in an expression and can lead to unexpected results and errors in your code.
There are 2 types :
There are two types of type coercion: implicit and explicit.
implicit:
Type coercion is the process of converting a value from one data type to another. In JavaScript, type coercion happens implicitly when operators or functions are applied to values of different types. For example, if you try to add a string and a number using the "+" operator, JavaScript will convert the number to a string and concatenate the two values.

let num = 10;
let str = "Hello";
console.log(str + num); // "Hello10"
explicit:
Explicit Coercion: Type conversion is done explicitly in code using the inbuilt functions like Number(), String(), Boolean(), etc.
let number = Number("35");
console.log(number);//35
    Logical operators:

Logical operators in javascript, unlike operators in other programming languages, do not return true or false. They always return one of the operands.

OR ( | | ) operator - If the first value is truthy, then the first value is returned. Otherwise, always the second value gets returned.

AND ( && ) operator - If both the values are truthy, always the second value is returned. If the first value is falsy then the first value is returned or if the second value is falsy then the second value is returned.

Example:

var x = 220;
var y = "Hello";
var z = undefined;
        
x | | y    // Returns 220 since the first value is truthy
        
x | | z   // Returns 220 since the first value is truthy
        
x && y    // Returns "Hello" since both the values are truthy
        
y && z   // Returns undefined since the second value is falsy
        
if( x && y ){ 
  console.log("Code runs" ); // This block runs because x && y returns "Hello" (Truthy)
}   
        
if( x || z ){
  console.log("Code runs");  // This block runs because x || y returns 220(Truthy)
}
13.
 What is NaN property in JavaScript?

NaN property represents the “Not-a-Number” value. It indicates a value that is not a legal number.

typeof of NaN will return a Number.

To check if a value is NaN, we use the isNaN() function,

    Note- isNaN() function converts the given value to a Number type, and then equates to NaN.

isNaN("Hello")  // Returns true
isNaN(345)   // Returns false
isNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) 
isNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)
isNaN(false) // Returns false
isNaN(undefined) // Returns true

14.
Explain passed by value and passed by reference?
In JavaScript, primitive data types are passed by value and non-primitive data types are passed by reference.
* For understanding passed by value and passed by reference, we need to understand what happens when we create a variable and assign a value to it,
* Basically, pass-by-value means that the actual value of the variable is passed and pass-by-reference means the memory location is passed 
where the value of the variable is stored.
var x = 2;

In the above example, we created a variable x and assigned it a value of “2”. In the background, the “=” (assign operator) allocates some space in the memory, stores the value “2” and returns the location of the allocated memory space. Therefore, the variable x in the above code points to the location of the memory space instead of pointing to the value 2 directly.

Assign operator behaves differently when dealing with primitive and non-primitive data types,

Assign operator dealing with primitive types:
var y = 234;
var z = y;

In the above example, the assign operator knows that the value assigned to y is a primitive type (number type in this case), so when the second line code executes, where the value of y is assigned to z, the assign operator takes the value of y (234) and allocates a new space in the memory and returns the address. Therefore, variable z is not pointing to the location of variable y, instead, it is pointing to a new location in the memory.

var y = #8454; // y pointing to address of the value 234

var z = y; 
     
var z = #5411; // z pointing to a completely new address of the value 234
     
// Changing the value of y
y = 23;
console.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z

From the above example, we can see that primitive data types when passed to another variable, are passed by value. Instead of just assigning the same address to another variable, the value is passed and new space of memory is created.
Assign operator dealing with non-primitive types:
var obj = { name: "Vivek", surname: "Bisht" };
var obj2 = obj;
In the above example, the assign operator directly passes the location of the variable obj to the variable obj2. In other words, the reference of the variable obj is passed to the variable obj2.
var obj = #8711;  // obj pointing to address of { name: "Vivek", surname: "Bisht" }
var obj2 = obj;
    
var obj2 = #8711; // obj2 pointing to the same address 
// changing the value of obj2
        
obj2.name = "Akki";
console.log(obj2);
        
// Returns {name:"Akki", surname:"Bisht"} since both the variables are pointing to the same address.
From the above example, we can see that while passing non-primitive data types, the assign operator directly passes the address (reference).

Therefore, non-primitive data types are always passed by reference.
15.In object redeclaration is possible because it's reference type:
const course = {
    lect:30,
    sub:"Math",
    title:"javascript",
    notes:{
        intro:"welcome to the course"
    },
    error(){
        console.log("Bye")
    },
    price:20
    
}
console.log(course);
course.price=300;//redeclare
console.log(course);